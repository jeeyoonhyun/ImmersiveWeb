{"ast":null,"code":"import _classCallCheck from \"/Users/jeeyoonhyun/immersive-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jeeyoonhyun/immersive-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/jeeyoonhyun/immersive-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/jeeyoonhyun/immersive-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { AdditiveBlending, Color, LinearFilter, MeshBasicMaterial, RGBAFormat, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nvar UnrealBloomPass = /*#__PURE__*/function (_Pass) {\n  _inherits(UnrealBloomPass, _Pass);\n\n  var _super = _createSuper(UnrealBloomPass);\n\n  function UnrealBloomPass(resolution, strength, radius, threshold) {\n    var _this;\n\n    _classCallCheck(this, UnrealBloomPass);\n\n    _this = _super.call(this);\n    _this.strength = strength !== undefined ? strength : 1;\n    _this.radius = radius;\n    _this.threshold = threshold;\n    _this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n    _this.clearColor = new Color(0, 0, 0); // render targets\n\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    };\n    _this.renderTargetsHorizontal = [];\n    _this.renderTargetsVertical = [];\n    _this.nMips = 5;\n    var resx = Math.round(_this.resolution.x / 2);\n    var resy = Math.round(_this.resolution.y / 2);\n    _this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n    _this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n    _this.renderTargetBright.texture.generateMipmaps = false;\n\n    for (var i = 0; i < _this.nMips; i++) {\n      var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n      renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n      renderTargetHorizonal.texture.generateMipmaps = false;\n\n      _this.renderTargetsHorizontal.push(renderTargetHorizonal);\n\n      var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n\n      _this.renderTargetsVertical.push(renderTargetVertical);\n\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    } // luminosity high pass material\n\n\n    if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n    var highPassShader = LuminosityHighPassShader;\n    _this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    _this.highPassUniforms['luminosityThreshold'].value = threshold;\n    _this.highPassUniforms['smoothWidth'].value = 0.01;\n    _this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: _this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {}\n    }); // Gaussian Blur Materials\n\n    _this.separableBlurMaterials = [];\n    var kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(_this.resolution.x / 2);\n    resy = Math.round(_this.resolution.y / 2);\n\n    for (var _i = 0; _i < _this.nMips; _i++) {\n      _this.separableBlurMaterials.push(_this.getSeperableBlurMaterial(kernelSizeArray[_i]));\n\n      _this.separableBlurMaterials[_i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    } // Composite material\n\n\n    _this.compositeMaterial = _this.getCompositeMaterial(_this.nMips);\n    _this.compositeMaterial.uniforms['blurTexture1'].value = _this.renderTargetsVertical[0].texture;\n    _this.compositeMaterial.uniforms['blurTexture2'].value = _this.renderTargetsVertical[1].texture;\n    _this.compositeMaterial.uniforms['blurTexture3'].value = _this.renderTargetsVertical[2].texture;\n    _this.compositeMaterial.uniforms['blurTexture4'].value = _this.renderTargetsVertical[3].texture;\n    _this.compositeMaterial.uniforms['blurTexture5'].value = _this.renderTargetsVertical[4].texture;\n    _this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n    _this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n    _this.compositeMaterial.needsUpdate = true;\n    var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n    _this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n    _this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    _this.compositeMaterial.uniforms['bloomTintColors'].value = _this.bloomTintColors; // copy material\n\n    if (CopyShader === undefined) {\n      console.error('THREE.UnrealBloomPass relies on CopyShader');\n    }\n\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyUniforms['opacity'].value = 1.0;\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.basic = new MeshBasicMaterial();\n    _this.fsQuad = new FullScreenQuad(null);\n    return _this;\n  }\n\n  _createClass(UnrealBloomPass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n        this.renderTargetsHorizontal[i].dispose();\n      }\n\n      for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {\n        this.renderTargetsVertical[_i2].dispose();\n      }\n\n      this.renderTargetBright.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resx = Math.round(width / 2);\n      var resy = Math.round(height / 2);\n      this.renderTargetBright.setSize(resx, resy);\n\n      for (var i = 0; i < this.nMips; i++) {\n        this.renderTargetsHorizontal[i].setSize(resx, resy);\n        this.renderTargetsVertical[i].setSize(resx, resy);\n        this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n        resx = Math.round(resx / 2);\n        resy = Math.round(resy / 2);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.setClearColor(this.clearColor, 0);\n      if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.basic;\n        this.basic.map = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n      } // 1. Extract Bright Areas\n\n\n      this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n      this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n      this.fsQuad.material = this.materialHighPassFilter;\n      renderer.setRenderTarget(this.renderTargetBright);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n      var inputRenderTarget = this.renderTargetBright;\n\n      for (var i = 0; i < this.nMips; i++) {\n        this.fsQuad.material = this.separableBlurMaterials[i];\n        this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n        this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n        this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetsVertical[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        inputRenderTarget = this.renderTargetsVertical[i];\n      } // Composite All the mips\n\n\n      this.fsQuad.material = this.compositeMaterial;\n      this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n      this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n      this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      } else {\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n      } // Restore renderer settings\n\n\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(kernelRadius) {\n      return new ShaderMaterial({\n        defines: {\n          'KERNEL_RADIUS': kernelRadius,\n          'SIGMA': kernelRadius\n        },\n        uniforms: {\n          'colorTexture': {\n            value: null\n          },\n          'texSize': {\n            value: new Vector2(0.5, 0.5)\n          },\n          'direction': {\n            value: new Vector2(0.5, 0.5)\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tfloat fSigma = float(SIGMA);\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, fSigma);\\n\\t\\t\\t\\t\\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\n\\t\\t\\t\\t\\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat x = float(i);\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(x, fSigma);\\n\\t\\t\\t\\t\\t\\tvec2 uvOffset = direction * invSize * x;\\n\\t\\t\\t\\t\\t\\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\n\\t\\t\\t\\t\\t\\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\n\\t\\t\\t\\t\\t\\tdiffuseSum += (sample1 + sample2) * w;\\n\\t\\t\\t\\t\\t\\tweightSum += 2.0 * w;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getCompositeMaterial\",\n    value: function getCompositeMaterial(nMips) {\n      return new ShaderMaterial({\n        defines: {\n          'NUM_MIPS': nMips\n        },\n        uniforms: {\n          'blurTexture1': {\n            value: null\n          },\n          'blurTexture2': {\n            value: null\n          },\n          'blurTexture3': {\n            value: null\n          },\n          'blurTexture4': {\n            value: null\n          },\n          'blurTexture5': {\n            value: null\n          },\n          'dirtTexture': {\n            value: null\n          },\n          'bloomStrength': {\n            value: 1.0\n          },\n          'bloomFactors': {\n            value: null\n          },\n          'bloomTintColors': {\n            value: null\n          },\n          'bloomRadius': {\n            value: 0.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D blurTexture1;\\n\\t\\t\\t\\tuniform sampler2D blurTexture2;\\n\\t\\t\\t\\tuniform sampler2D blurTexture3;\\n\\t\\t\\t\\tuniform sampler2D blurTexture4;\\n\\t\\t\\t\\tuniform sampler2D blurTexture5;\\n\\t\\t\\t\\tuniform sampler2D dirtTexture;\\n\\t\\t\\t\\tuniform float bloomStrength;\\n\\t\\t\\t\\tuniform float bloomRadius;\\n\\t\\t\\t\\tuniform float bloomFactors[NUM_MIPS];\\n\\t\\t\\t\\tuniform vec3 bloomTintColors[NUM_MIPS];\\n\\n\\t\\t\\t\\tfloat lerpBloomFactor(const in float factor) {\\n\\t\\t\\t\\t\\tfloat mirrorFactor = 1.2 - factor;\\n\\t\\t\\t\\t\\treturn mix(factor, mirrorFactor, bloomRadius);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }]);\n\n  return UnrealBloomPass;\n}(Pass);\n\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"sources":["/Users/jeeyoonhyun/immersive-web/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"names":["AdditiveBlending","Color","LinearFilter","MeshBasicMaterial","RGBAFormat","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","LuminosityHighPassShader","UnrealBloomPass","resolution","strength","radius","threshold","undefined","x","y","clearColor","pars","minFilter","magFilter","format","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","console","error","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","length","dispose","width","height","setSize","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","render","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius"],"mappings":"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","sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tif ( LuminosityHighPassShader === undefined )\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on LuminosityHighPassShader' );\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader,\n\t\t\tdefines: {}\n\t\t} );\n\n\t\t// Gaussian Blur Materials\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// Composite material\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\t\tthis.compositeMaterial.needsUpdate = true;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// copy material\n\t\tif ( CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on CopyShader' );\n\n\t\t}\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius,\n\t\t\t\t'SIGMA': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'dirtTexture': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"]},"metadata":{},"sourceType":"module"}