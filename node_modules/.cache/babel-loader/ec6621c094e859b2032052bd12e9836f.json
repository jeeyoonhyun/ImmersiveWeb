{"ast":null,"code":"import { AdditiveBlending, Color, LinearFilter, MeshBasicMaterial, RGBAFormat, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nclass UnrealBloomPass extends Pass {\n  constructor(resolution, strength, radius, threshold) {\n    super();\n    this.strength = strength !== undefined ? strength : 1;\n    this.radius = radius;\n    this.threshold = threshold;\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n    this.clearColor = new Color(0, 0, 0); // render targets\n\n    const pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    };\n    this.renderTargetsHorizontal = [];\n    this.renderTargetsVertical = [];\n    this.nMips = 5;\n    let resx = Math.round(this.resolution.x / 2);\n    let resy = Math.round(this.resolution.y / 2);\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n    this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n    this.renderTargetBright.texture.generateMipmaps = false;\n\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n      renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n      renderTargetHorizonal.texture.generateMipmaps = false;\n      this.renderTargetsHorizontal.push(renderTargetHorizonal);\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n      this.renderTargetsVertical.push(renderTargetVertical);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    } // luminosity high pass material\n\n\n    if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n    const highPassShader = LuminosityHighPassShader;\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    this.highPassUniforms['luminosityThreshold'].value = threshold;\n    this.highPassUniforms['smoothWidth'].value = 0.01;\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {}\n    }); // Gaussian Blur Materials\n\n    this.separableBlurMaterials = [];\n    const kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(this.resolution.x / 2);\n    resy = Math.round(this.resolution.y / 2);\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    } // Composite material\n\n\n    this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n    this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n    this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n    this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n    this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n    this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n    this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n    this.compositeMaterial.needsUpdate = true;\n    const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n    this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n    this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n    if (CopyShader === undefined) {\n      console.error('THREE.UnrealBloomPass relies on CopyShader');\n    }\n\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms['opacity'].value = 1.0;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.basic = new MeshBasicMaterial();\n    this.fsQuad = new FullScreenQuad(null);\n  }\n\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  }\n\n  setSize(width, height) {\n    let resx = Math.round(width / 2);\n    let resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    let inputRenderTarget = this.renderTargetBright;\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  }\n\n  getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        'KERNEL_RADIUS': kernelRadius,\n        'SIGMA': kernelRadius\n      },\n      uniforms: {\n        'colorTexture': {\n          value: null\n        },\n        'texSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'direction': {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n    });\n  }\n\n  getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        'NUM_MIPS': nMips\n      },\n      uniforms: {\n        'blurTexture1': {\n          value: null\n        },\n        'blurTexture2': {\n          value: null\n        },\n        'blurTexture3': {\n          value: null\n        },\n        'blurTexture4': {\n          value: null\n        },\n        'blurTexture5': {\n          value: null\n        },\n        'dirtTexture': {\n          value: null\n        },\n        'bloomStrength': {\n          value: 1.0\n        },\n        'bloomFactors': {\n          value: null\n        },\n        'bloomTintColors': {\n          value: null\n        },\n        'bloomRadius': {\n          value: 0.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n    });\n  }\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"sources":["/Users/jeeyoonhyun/immersive-web/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"names":["AdditiveBlending","Color","LinearFilter","MeshBasicMaterial","RGBAFormat","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","LuminosityHighPassShader","UnrealBloomPass","constructor","resolution","strength","radius","threshold","undefined","x","y","clearColor","pars","minFilter","magFilter","format","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","console","error","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius"],"mappings":"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","sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tif ( LuminosityHighPassShader === undefined )\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on LuminosityHighPassShader' );\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader,\n\t\t\tdefines: {}\n\t\t} );\n\n\t\t// Gaussian Blur Materials\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// Composite material\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\t\tthis.compositeMaterial.needsUpdate = true;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// copy material\n\t\tif ( CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on CopyShader' );\n\n\t\t}\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius,\n\t\t\t\t'SIGMA': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'dirtTexture': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"]},"metadata":{},"sourceType":"module"}